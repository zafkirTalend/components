package org.talend.components.cassandra.runtime;

import com.datastax.driver.core.DataType;
import com.datastax.driver.core.GettableByIndexData;
import com.datastax.driver.core.SettableByIndexData;
import org.apache.avro.Schema;
import org.apache.avro.Schema.Field;
import org.apache.avro.generic.IndexedRecord;
import org.apache.avro.reflect.ReflectData;
import org.apache.avro.specific.SpecificData;
import org.talend.daikon.avro.AvroUtils;
import org.talend.daikon.avro.container.ContainerReaderByIndex;
import org.talend.daikon.avro.container.ContainerWriterByIndex;
import org.talend.daikon.avro.converter.AvroConverter;
import org.talend.daikon.avro.converter.IndexedRecordConverter;
import org.talend.daikon.avro.converter.HasNestedAvroConverter;

import java.util.ArrayList;
import java.util.List;

import static org.talend.daikon.avro.AvroUtils.unwrapIfNullable;

/**
 * A base structure for between Cassandra and Avro-compatible objects in the form of Avro records.
 * <p>
 * This is a good example of how to construct an {@link IndexedRecordConverter} that supports all Avro collection
 * structures, and caches the converter objects that it needs to access them.
 * <p>
 * {@link GettableByIndexData} is a common Cassandra-specific interface for fetching data, but doesn't contain any
 * information about the data type per field. Specific implementations of this factory are necessary to obtain this data
 * for inferring the {@link Schema}.
 */
public abstract class CassandraBaseAdapterFactory<GettableT extends GettableByIndexData, SettableT extends SettableByIndexData<SettableT>, TypeT>
        implements IndexedRecordConverter<GettableT, IndexedRecord>, HasNestedAvroConverter<GettableT, IndexedRecord> {

    /**
     * Every {@link IndexedRecord} generated by this factory should use the same schema.
     */
    private Schema mSchema;

    /**
     * A container type associated with the factory. This does not change once discovered.
     */
    protected transient TypeT mContainerType;

    /**
     * The cached Cassandra DataType objects for the fields of this record.
     */
    protected transient DataType[] mFieldType;

    /**
     * The cached AvroConverter objects for the fields of this record.
     */
    @SuppressWarnings("rawtypes")
    protected transient AvroConverter[] mFieldConverter;

    /**
     * The cached ContainerReaderByIndex objects for the fields of this record.
     */
    protected transient ContainerReaderByIndex<GettableByIndexData, ?>[] mFieldReader;

    /**
     * The cached ContainerReaderByIndex objects for the fields of this record.
     */
    protected transient ContainerWriterByIndex<SettableByIndexData<?>, ?>[] mFieldWriter;

    /**
     * @return the container type for this factory. The container type can be used to access the field types.
     */
    public TypeT getContainerType() {
        return mContainerType;
    }

    /**
     * Set the container type for this factory. This automatically initializes the {@link Schema} using the inferrers.
     *
     * @param containerType A container type can be used to access the field types.
     */
    public void setContainerType(TypeT containerType) {
        mContainerType = containerType;
        setSchema(CassandraAvroRegistry.get().inferSchema(containerType));
    }

    /**
     * Given an instance of an object, sets the container type.
     */
    protected abstract void setContainerTypeFromInstance(GettableT gettable);

    /**
     * @param i The index of the field.
     * @return The Cassandra-specific DataType for that field.
     */
    protected abstract DataType getFieldType(int i);

    protected abstract SettableT createOrGetInstance();

    @SuppressWarnings("unchecked")
    @Override
    public Iterable<AvroConverter<?, ?>> getNestedAvroConverters() {
        for (Field f : unwrapIfNullable(getSchema()).getFields()) {
            int i = f.pos();
            if (mFieldType[i] == null) {
                mFieldType[i] = getFieldType(i);
            }
            if (mFieldConverter[i] == null) {
                mFieldConverter[i] = CassandraAvroRegistry.get().getConverter(mFieldType[i],
                        f.schema(), null);
            }
        }
        List<AvroConverter<?, ?>> list = new ArrayList<>();
        for (AvroConverter avroConverter : mFieldConverter) {
            list.add(avroConverter);
        }
        return list;
    }

    /**
     * @return the Schema used for {@link IndexedRecord}s created by this factory, or null if no Schema has been set or
     * inferred from existing data.
     */
    @Override
    public Schema getSchema() {
        return mSchema;
    }

    /**
     * Sets the known schema for this factory to the given value, which will be used for all subsequent generated
     * {@link IndexedRecord}s, or re-inferred from incoming data if null.
     */
    @Override
    public void setSchema(Schema schema) {
        mSchema = schema;
        if (schema != null) {
            // Initialized on the first convertToAvro or convertToDatum call.
            mFieldType = new DataType[unwrapIfNullable(mSchema).getFields().size()];
            // Initialized on the first get(i) call on the indexed record for that field.
            mFieldConverter = new AvroConverter[mFieldType.length];
        }
    }

    @SuppressWarnings("unchecked")
    @Override
    public IndexedRecord convertToAvro(GettableT gettable) {
        if (mContainerType == null) {
            setContainerTypeFromInstance(gettable);
        }

        GettableAdapterIndexedRecord record = new GettableAdapterIndexedRecord(gettable);

        if (mFieldReader == null) {
            mFieldReader = new ContainerReaderByIndex[mFieldType.length];
            for (Field f : unwrapIfNullable(getSchema()).getFields()) {
                int i = f.pos();
                mFieldType[i] = getFieldType(i);
                mFieldReader[i] = CassandraAvroRegistry.get().getReader(mFieldType[i]);
            }
        }

        return record;
    }

    @SuppressWarnings("unchecked")
    @Override
    public GettableT convertToDatum(IndexedRecord record) {

        if (mFieldWriter == null) {
            mFieldWriter = new ContainerWriterByIndex[mFieldType.length];
            for (Field f : unwrapIfNullable(getSchema()).getFields()) {
                int i = f.pos();
                mFieldType[i] = getFieldType(i);
                mFieldWriter[i] = CassandraAvroRegistry.get().getWriter(mFieldType[i]);
            }
        }

        SettableT value = createOrGetInstance();

        for (Field f : unwrapIfNullable(getSchema()).getFields()) {
            int fieldIndex = f.pos();
            if (mFieldType[fieldIndex] == null)
                mFieldType[fieldIndex] = getFieldType(fieldIndex);
            Object fieldValue = record.get(fieldIndex);

            if (fieldValue == null) {
                value.setToNull(fieldIndex);
                continue;
            }

            if (mFieldConverter[fieldIndex] == null)
                mFieldConverter[fieldIndex] = CassandraAvroRegistry.get().getConverter(mFieldType[fieldIndex], f.schema(),
                        fieldValue.getClass());

            ContainerWriterByIndex<SettableByIndexData<?>, Object> writer = (ContainerWriterByIndex<SettableByIndexData<?>, Object>) CassandraAvroRegistry
                    .get().getWriter(mFieldType[fieldIndex]);

            writer.writeValue(value, f.pos(), mFieldConverter[fieldIndex].convertToDatum(fieldValue));
        }
        return (GettableT) value;
    }

    /**
     * A adapter that maps the given {@link GettableByIndexData} to have the appearance of an Avro {@link IndexedRecord}.
     */
    public class GettableAdapterIndexedRecord implements IndexedRecord, Comparable<IndexedRecord> {

        /**
         * The wrapped GettableByIndexData object.
         */
        public GettableT mGettable;

        public GettableAdapterIndexedRecord(GettableT gettable) {
            mGettable = gettable;
        }

        public GettableT getRow() {
            return mGettable;
        }

        public void setRow(GettableT r) {
            mGettable = r;
        }

        public Schema getSchema() {
            return mSchema;
        }

        @Override
        public void put(int i, Object v) {
            // This should never happen.
            throw new UnsupportedOperationException("Should not write to a read-only item.");
        }

        @SuppressWarnings("unchecked")
        @Override
        public Object get(int i) {
            //FIXME(bchen) need conversion between suggestion avro type and user define avro type here!!!!!!
            Object value = mFieldReader[i].readValue(mGettable, i);
            if (value == null)
                return null;

            if (mFieldConverter[i] == null) {
                mFieldConverter[i] = CassandraAvroRegistry.get().getConverter(mFieldType[i],
                        unwrapIfNullable(mSchema).getFields().get(i).schema(), value.getClass());
            }

            if (mFieldConverter[i] != null) {
                value = mFieldConverter[i].convertToAvro(value);
            }

            return value;
        }

        @Override
        public int hashCode() {
            // Base the hash code only on the schema.
            return SpecificData.get().hashCode(this, getSchema());
        }

        @Override
        public boolean equals(Object that) {
            if (that == this)
                return true; // identical object
            if (!(that instanceof IndexedRecord))
                return false; // not a record
            return compareTo((IndexedRecord) that) == 0;
        }

        @Override
        public String toString() {
            return mGettable.toString();
        }

        @Override
        public int compareTo(IndexedRecord that) {
            return ReflectData.get().compare(this, that, getSchema());
        }

    }
}
